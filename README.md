# Исследование алгоритмов сортировки и поиска на различных языках программирования

## Сортировка выбором
Сортировка выбором - алгоритм, который на каждом шаге находит самый маленький элемент в неотсортированной части и ставит его в начало.

Как работает:
Функция проходит по массиву внешним циклом. Для каждой позиции внутренний цикл ищет минимальный элемент в оставшейся части. Когда минимальный найден, он меняется местами с текущим элементом. Так постепенно формируется отсортированный массив.

Сложность:
Время: O(n²)
Память: O(1)

## Сортировка пузырьком
Пузырьковая сортировка многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они стоят неправильно.

Как работает:
Алгоритм использует два цикла. Внешний цикл определяет количество проходов, внутренний - попарно сравнивает элементы. Большие элементы постепенно "всплывают" к концу массива, как пузырьки.

Сложность:
Время: O(n²)
Память: O(1)

## Сортировка вставками
Алгоритм строит отсортированную часть, вставляя каждый следующий элемент в нужное место среди уже упорядоченных.

Как работает:
Начинаем со второго элемента. Для каждого элемента находим правильную позицию в отсортированной части, сдвигая большие элементы вправо. Вставляем элемент на найденное место.

Сложность:
Время: O(n²)
Память: O(1)

## Сортировка слиянием
Алгоритм делит массив пополам, сортирует каждую половину отдельно, затем объединяет их.

Как работает:
Рекурсивно разбиваем массив на меньшие части до тех пор, пока не останутся массивы из одного элемента. Затем сливаем отсортированные части в правильном порядке.

Сложность:
Время: O(n log n)
Память: O(n)

## Сортировка Шелла
Улучшенная версия сортировки вставками, которая сравнивает элементы на определенном расстоянии.

Как работает:
Начинаем с большого шага (расстояния между сравниваемыми элементами). Постепенно уменьшаем шаг до 1. На каждом шаге сортируем элементы, находящиеся на этом расстоянии.

Сложность:
Время: O(n log²n)
Память: O(1)

## Быстрая сортировка
Алгоритм выбирает опорный элемент и разделяет массив на две части: меньшие и большие опорного.

Как работает:
Выбираем опорный элемент. Переставляем элементы так, чтобы слева были меньшие, справа - большие. Рекурсивно применяем алгоритм к обеим частям.

Сложность:
Время: O(n log n) в среднем
Память: O(log n)

## Пирамидальная сортировка
Использует структуру "куча" для организации данных в виде дерева.

Как работает:
Сначала преобразуем массив в кучу, где родитель всегда больше потомков. Затем многократно извлекаем максимальный элемент и перестраиваем кучу.

Сложность:
Время: O(n log n)
Память: O(1)

## Линейный поиск
Простейший алгоритм поиска, который проверяет элементы по порядку.

Как работает:
Последовательно перебираем все элементы массива от начала до конца. Сравниваем каждый элемент с искомым значением. Если нашли - возвращаем индекс, если дошли до конца - возвращаем -1.

Сложность:
Время: O(n)
Память: O(1)

## Бинарный поиск
Эффективный алгоритм для поиска в отсортированном массиве.

Как работает:
Начинаем с всего массива. На каждом шаге сравниваем средний элемент с искомым. Если не нашли - отбрасываем половину массива и продолжаем поиск в оставшейся части.

Сложность:
Время: O(log n)
Память: O(1)

## Интерполяционный поиск
Улучшенный бинарный поиск, который предсказывает позицию элемента.

Как работает:
Вместо деления массива пополам, вычисляем вероятную позицию элемента на основе его значения и значений на границах. Особенно эффективен для равномерно распределенных данных.

Сложность:
Время: O(log log n) в среднем
Память: O(1)

## Поиск Фибоначчи
Вариант бинарного поиска, использующий числа Фибоначчи.

Как работает:
Использует числа Фибоначчи для определения точек разделения массива. На каждом шаге исключает примерно треть элементов, что делает его немного эффективнее бинарного поиска.

Сложность:
Время: O(log n)
Память: O(1)
