# Исследование алгоритмов сортировки и поиска

## Алгоритмы сортировки

### Сортировка выбором
Алгоритм, который на каждом шаге находит самый маленький элемент в неотсортированной части и ставит его в начало.

**Объяснение работы алгоритма:**
Функция `sortBySelection()` обрабатывает массив, используя внешний цикл для определения текущей позиции. Для каждой позиции внутренний цикл ищет минимальный элемент в оставшейся части. Когда минимальный элемент найден, он меняется местами с элементом на текущей позиции через временную переменную. Так постепенно формируется отсортированная последовательность.

**Сложность:**  
Время: O(n²)  
Память: O(1)

### Сортировка пузырьком
Простой алгоритм, который многократно проходит по массиву, сравнивая и меняя местами соседние элементы.

**Объяснение работы алгоритма:**
Функция `bubble_sort()` использует вложенные циклы для многократного прохода по массиву. Внешний цикл определяет количество проходов, внутренний цикл выполняет попарное сравнение соседних элементов. Условие `if sequence[index] > sequence[index + 1]` определяет необходимость обмена. В улучшенной версии используется флаг `has_swapped` для досрочного завершения при отсутствии обменов.

**Сложность:**  
Время: O(n²)  
Память: O(1)

### Сортировка вставками
Алгоритм строит отсортированную часть, вставляя каждый следующий элемент в нужное место.

**Объяснение работы алгоритма:**
Функция `sortByInsertion()` обрабатывает элементы начиная со второго. Для каждого элемента запоминается его значение в переменной `valueToInsert`. Внутренний цикл `while` сдвигает элементы отсортированной части, которые больше вставляемого значения. Финальная операция помещает элемент на найденную позицию.

**Сложность:**  
Время: O(n²)  
Память: O(1)

### Сортировка слиянием
Алгоритм делит массив пополам, сортирует каждую половину отдельно, затем объединяет их.

**Объяснение работы алгоритма:**
Функция `sortByMerge()` рекурсивно разделяет массив до базового случая (массивы длиной 1). Функция `combineArrays()` объединяет отсортированные части: основной цикл сравнивает элементы левого и правого массивов, выбирая меньший, дополнительные циклы добавляют оставшиеся элементы.

**Сложность:**  
Время: O(n log n)  
Память: O(n)

### Сортировка Шелла
Улучшенная версия сортировки вставками, которая сравнивает элементы на определенном расстоянии.

**Объяснение работы алгоритма:**
Функция `shell_sort()` начинает с шага `step = size // 2`. Внутренний цикл обрабатывает элементы с текущим шагом, используя модифицированную сортировку вставками. Версия Кнута использует последовательность `3 * step + 1` для вычисления шага.

**Сложность:**  
Время: O(n log²n)  
Память: O(1)

### Быстрая сортировка
Алгоритм выбирает опорный элемент и разделяет массив на две части.

**Объяснение работы алгоритма:**
Функция `quickSort()` рекурсивно вызывает себя. Функция `splitArray()` выбирает опорный элемент `pivot` как последний элемент, переставляет элементы так, чтобы слева были меньшие, справа - большие, возвращает позицию опорного элемента.

**Сложность:**  
Время: O(n log n) в среднем  
Память: O(log n)

### Пирамидальная сортировка
Использует структуру "куча" для организации данных.

**Объяснение работы алгоритма:**
Функция `sortWithHeap()` сначала строит max-heap вызовами `adjustHeap()` для нелистовых узлов. Затем последовательно извлекает максимальные элементы, перемещая корень в конец и перестраивая кучу. Функция `adjustHeap()` поддерживает свойство кучи, сравнивая корень с потомками.

**Сложность:**  
Время: O(n log n)  
Память: O(1)

## Алгоритмы поиска

### Линейный поиск
Простейший алгоритм, который проверяет элементы по порядку.

**Объяснение работы алгоритма:**
Функция `sequential_search()` перебирает все элементы массива последовательно. На каждой итерации проверяется условие `if items[index] == value_to_find`. При нахождении элемента возвращается его индекс, иначе -1.

**Сложность:**  
Время: O(n)  
Память: O(1)

### Бинарный поиск
Эффективный алгоритм для поиска в отсортированном массиве.

**Объяснение работы алгоритма:**
Функция `binary_search()` использует границы `start` и `end`. На каждой итерации вычисляется `center`, сравнивается с искомым значением. В зависимости от результата границы сужаются до тех пор, пока элемент не будет найден или диапазон не станет пустым.

**Сложность:**  
Время: O(log n)  
Память: O(1)

### Интерполяционный поиск
Улучшенный бинарный поиск, который предсказывает позицию элемента.

**Объяснение работы алгоритма:**
Функция `searchInterpolation()` вычисляет предполагаемую позицию по формуле интерполяции. Рекурсивно вызывает себя для левой или правой части в зависимости от сравнения. Итеративная версия использует цикл while с обновлением границ.

**Сложность:**  
Время: O(log log n) в среднем  
Память: O(1)

### Поиск Фибоначчи
Вариант бинарного поиска, использующий числа Фибоначчи.

**Объяснение работы алгоритма:**
Функция `findWithFibonacci()` использует три числа Фибоначчи для определения позиций проверки. На каждом шаге алгоритм исключает примерно 1/3 элементов, обновляя числа Фибоначчи и смещение.

**Сложность:**  
Время: O(log n)  
Память: O(1)

## Общие выводы

Проанализированные алгоритмы сортировки демонстрируют различные подходы к упорядочиванию данных. Простые алгоритмы (выбором, пузырьком, вставками) имеют квадратичную сложность, но легки в реализации. Эффективные алгоритмы (слиянием, быстрая, пирамидальная) используют разделение на части и имеют сложность O(n log n).

Алгоритмы поиска показывают, что для неотсортированных данных подходит линейный поиск, тогда как для отсортированных массивов более эффективны бинарный поиск и его модификации. Выбор конкретного алгоритма зависит от характеристик данных и требований к производительности.
